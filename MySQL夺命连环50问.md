# MySQL夺命连环50问

```mysql
#使用explain可以查看语句执行的详细信息，可以看到查找类型是否用了索引，extra里面还能看到用了具体怎样的方式

explain select b from t1 where b>1;


```



回表是执行的磁盘IO操作是吧？



> B树和B+树之间的区别是什么？
>	B+树是把所有数据都放在了叶子节点上，根节点和子节点上都是存放索引
>	B树每个节点上都存有数据
>	B+树的叶子节点之间有双向指针，可以更好的支持范围查找
>	
>
>
> Innodb中的B+树有什么特点？
>
> 什么是Innodb中的page？
>
> Innodb中的B+树是怎么产生的？
>
> 什么是聚簇索引？
>
> Innodb是如何支持范围查找能走索引的？
>
> 什么是联合索引？对应的B+树是如何生成的？
>
> 什么是最左前缀原则？
>
> 为什么要遵守最左前缀原则才能利用到索引?
>
> 什么是索引条件下推？
>
> 什么是覆盖索引？
>
> 有哪些情况会导致索引失效？





##### 1. B树和B+树之间的区别是什么？

B+树是在B树基础上加了点小升级，Innodb中的B+树是在叶子结点之间加了双向指针，这有很有利于范围查找



##### 2. Innodb中的B+树是怎么产生的？

每一页16KB，一页中可以存若干条数据，通过【页目录】使查找数据更快，类似于我们通过书的目录快速查找某个内容是否在书中。

页和页之间也有指针（next），形成一个链表。

对于主键，数据在插入过程中是会排序插入的，所以主键最好是好排序的类型



##### 3. 高度为3的B+树能存多少数据

两层B+树能存多少数据，取决于所存数据的类型，类型不同所占空间大小不同

树的根节点应该就一个吧，两层B+树，第二层应该就是一个节点——根节点

**计算思路：首先算出叶子结点一页能存多少数据，然后算出根节点一页能存多少个叶子结点**

（一个叶子结点就是一页、一page）

那么根据Innodb中：

①一页大小是16KB

②int类型占4byte+一个指针6byte=10byte（一对）

③第二层（根节点）中存一对，就是代表了第一层（叶子结点）的一页

可以计算出根节点中可以存放多少对叶子结点，即多少页：

​	（16KB * 1024）/ 10byte = 1638.4（对/页）

然后计算出叶子结点一页能存多少数据，就能得出两层B+树一共能存多少数据了

假设所存数据一条1KB，那么一页就是：

​	16KB / 1KB = 16（条）

最终，可以计算出：

​	1638 * 16 = 26208(条)

可以存两万多条

那三层就是：

​	1638 * 1638 * 16 = 4200多万条 

**一般来说最多三层就行了，如果你要存的数据超过三层能存的条数，就建议分库分表了**



##### 4. Innodb是如何支持范围查找能走索引的？

> 索引页和数据页在一起的，叫做**聚簇/聚集索引**，比如主键索引就是**聚簇索引**。
>
> 走不了索引，就是全表扫描

```mysql
explain select * from t1 where a > 6;
explain select * from t1 where a < 6;

# 利用索引先按照a=6找，然后利用MySQLB+树的双向指针（更好的支持了范围查找）就可以找到
```





##### 5. 为什么要遵守最左前缀原则才能利用到索引？什么是索引条件下推？

```mysql
# 这就是在创建联合索引
create index idx_t1_bcd on t1(b,c,d); 
#生成索引是把数据按照bcd三个字段排序，然后生成索引的；先比较b，b一样就比较c，同理，最后比较d
#非主键索引叶子结点还存了主键id，联合索引的叶子结点同理，存了联合字段的信息+主键值，而你拿到主键值再去主键索引那边找数据的时候就叫做【回表】（和myism中的回表不太一样）

explain select * from t1 where b=1 and c=1 and d=1;  --可以走索引
explain select * from t1 where c=1 and d=1 and b=1;  --也可以，where后面的顺序不影响
explain select * from t1 where c=1 and d=1; --走不了，因为先从最左边开始比较，最左边b缺失，所以不符合最左前缀原则了 

explain select * from t1 where b=1 and d=1;
Extra里面写的【Using index condition】就叫索引条件下推，这是5.6版本后MySQL自身的一个优化，优化了回表的次数，在使用b=1筛选完后，直接在bcd这个索引树里面用d=1筛选，而不是先回表再去筛选。



```



##### 6. 范围查找导致索引失效原理分析？

因为查询范围不够精确或者啥原因，导致回表次数太多了



##### 7. 覆盖索引的底层原理？

查询的内容是索引所能覆盖到的，那么就可以走索引了，不需要去回表，主键肯定是在索引上找到的



##### 8. 索引扫描的底层原理？

只要索引能覆盖查询的数据，索引扫描也比全表扫描快，是因为全量数据肯定比索引占得页多吧，那肯定页少一些的索引全部扫描更快

```mysql
# 在索引包含b字段的情况下
explain select b from t1
```



##### 9. order by为什么会导致索引失效

其实根本上还是因为回表次数太多导致的，比如索引没有覆盖要查询的全部内容，必须得回表

```mysql
explain select * from t1 order by b,c,d

# 没有where条件，没办法从上往下走索引，只能是索引扫描（扫描索引树的所有叶子节点），虽然索引扫描是排好序的 
# 由于是select *，索引没有覆盖查询数据，得回表，所以没有走索引查询，走得是全表扫描
# 在内存中排序是非常快的
```



##### 10. 	MySQL中的数据类型转换有哪些要注意的

- 不同国家对字符间排序可能是不一样的喔

- 等式判定时候，MySQL会把非数字类型的字符都转换为数字0（纯数字字符串还是会转成数字的）

  ```mysql
  select 'a'=0;  -- 1 结果为1 
  
  select '123'=123  -- 1 结果为1
  ```

- 发生数据类型转换时，会导致索引失效

  ```mysql
  create index idx_t1_e on t1(e);
  
  explain select * from t1 where a = '1';  --能走索引，因为'1'会先转为1
  explain select * from t1 where e = 1;  --没走索引 因为e字段是varchar类型，会先把e字段的内容转换成数字，然后和1去比较，要把所有索引里的内容都修改 这都是磁盘操作，而且如果其他地方也用到e的索引，那不就改废了给人家，所以没法走索引
  ```

  

##### 11. 对字段进行操作（运算or进行了类型转换）导致索引失效原理

原因同上，因为如果修改索引的话成本太高

```mysql
select * from t1 where a+1 = 1;
select * from t1 where e = 1;
```





##### 12. MySQL中有哪些存储引擎？
